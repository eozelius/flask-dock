{"remainingRequest":"/Users/ethan/vue/minesweeper/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/ethan/vue/minesweeper/src/components/Board.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/ethan/vue/minesweeper/src/components/Board.vue","mtime":1550239794494},{"path":"/Users/ethan/vue/minesweeper/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ethan/vue/minesweeper/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/ethan/vue/minesweeper/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/ethan/vue/minesweeper/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport Cell from \"@/components/Cell.vue\";\nimport { mapState, mapGetters, mapActions } from \"vuex\";\n\nexport default {\n  name: \"Board\",\n\n  data: () => {\n    return {\n      board: [],\n      rows: 4,\n      cols: 4,\n      mines: 4,\n      safeCells: 0\n    };\n  },\n\n  mounted() {\n    this.generateBoard(this.rows, this.cols, this.mines);\n  },\n\n  computed: {\n    ...mapState({\n      shouldGenerateBoard: state => state.board.shouldGenerateBoard\n    }),\n    ...mapGetters([\"resetRows\", \"resetCols\", \"resetMines\"])\n  },\n\n  watch: {\n    shouldGenerateBoard(shouldGenerate) {\n      if (shouldGenerate) {\n        // console.log(\"watch reset\");\n        // console.log(this.resetRows, this.resetCols, this.resetMines);\n        this.generateBoard(this.resetRows, this.resetCols, this.resetMines);\n      }\n    }\n  },\n\n  methods: {\n    ...mapActions([\"startGame\", \"resetGenerateBoard\"]),\n\n    randomNum: max => {\n      // return a random number between 0 and max inclusively\n      return Math.floor(Math.random() * Math.floor(max));\n    },\n\n    generateBoard(rows = this.rows, cols = this.cols, mines = this.mines) {\n      // console.log(\"Baord.generateBoard\");\n      // console.log(rows);\n      // console.log(cols);\n      // console.log(mines);\n\n      if (!this.validGame(rows, cols, mines)) {\n        // console.log(\"invalid game returning false\");\n        return false;\n      }\n\n      this.rows = rows;\n      this.cols = cols;\n      this.mines = mines;\n\n      // calculate number of cells that are not mines.\n      this.safeCells = rows * cols - mines;\n\n      // Helper function to return a list of cells that do not have a mine place in them.\n      const getAvailableCells = () => {\n        const availableCells = [];\n        for (let i = 0; i < rows; i++) {\n          for (let j = 0; j < cols; j++) {\n            if (!this.board[i][j].mine) {\n              availableCells.push([i, j]);\n            }\n          }\n        }\n        return availableCells;\n      };\n\n      // Initialize board to entirely empty but active cells\n      for (let r = 0; r < rows; r++) {\n        this.$set(this.board, r, []);\n        for (let c = 0; c < cols; c++) {\n          this.$set(this.board[r], c, {\n            mine: false,\n            active: true,\n            borderMines: 0,\n            flag: false,\n            reveal: false\n          });\n        }\n      }\n\n      // Place mines\n      for (let m = 0; m < mines; m++) {\n        const availableCells = getAvailableCells();\n        const randomNum = this.randomNum(availableCells.length);\n        const cell = availableCells[randomNum];\n        const row = cell[0];\n        const col = cell[1];\n        this.$set(this.board[row][col], \"mine\", true);\n      }\n\n      // Determine Border Mines\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          if (!this.board[i][j].mine) {\n            continue;\n          }\n\n          // North\n          if (i - 1 >= 0) {\n            const neighbor = this.board[i - 1][j];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // NorthEast\n          if (i - 1 >= 0 && j + 1 < cols) {\n            const neighbor = this.board[i - 1][j + 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // East\n          if (j + 1 < cols) {\n            const neighbor = this.board[i][j + 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // SouthEast\n          if (i + 1 < rows && j + 1 < cols) {\n            const neighbor = this.board[i + 1][j + 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // South\n          if (i + 1 < rows) {\n            const neighbor = this.board[i + 1][j];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // SouthWest\n          if (i + 1 < rows && j - 1 >= 0) {\n            const neighbor = this.board[i + 1][j - 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // West\n          if (j - 1 >= 0) {\n            const neighbor = this.board[i][j - 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // NorthWest\n          if (i - 1 >= 0 && j - 1 >= 0) {\n            const neighbor = this.board[i - 1][j - 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n        }\n      }\n\n      this.resetGenerateBoard();\n    },\n\n    handleFlagClick(row, col) {\n      // Removing Flag\n      if (this.board[row][col].flag) {\n        this.$set(this.board[row][col], \"flag\", false);\n        this.$set(this.board[row][col], \"active\", true);\n        this.mines++;\n        return;\n      }\n\n      // Replace a number with a flag\n      if (!this.board[row][col].active) {\n        this.$set(this.board[row][col], \"flag\", true);\n        this.mines--;\n        this.safeCells++;\n        return;\n      }\n\n      this.$set(this.board[row][col], \"flag\", true);\n      this.$set(this.board[row][col], \"active\", false);\n      this.mines--;\n\n      // console.log(\"TODO => won Game?  Minesweeper.gameWon()\");\n      // this.gameWon();\n    },\n\n    handleClick(row, col, flag) {\n      // First Click\n      if (this.allCellsActive()) {\n        this.startGame();\n      }\n\n      if (flag) {\n        this.handleFlagClick(row, col);\n        return;\n      }\n\n      // this cell has already been clicked\n      if (!this.board[row][col].active) {\n        return false;\n      }\n\n      // Set Cell to Inactive\n      this.$set(this.board[row][col], \"active\", false);\n      this.safeCells--;\n\n      // Triggered a mine\n      if (this.board[row][col].mine) {\n        this.youLost = true;\n        this.gameActive = false;\n        this.revealMines();\n        this.pauseTimer();\n        return;\n      }\n\n      // console.log(\"TODO => won Game?  Minesweeper.gameWon()\");\n      // this.gameWon();\n    },\n\n    validGame(rows, cols, mines) {\n      this.errors = [];\n\n      if (isNaN(rows)) {\n        this.errors.push(\"Rows is not a number.\");\n      }\n\n      if (isNaN(cols)) {\n        this.errors.push(\"Columns is not a number.\");\n      }\n\n      if (isNaN(mines)) {\n        this.errors.push(\"Mines is not a number.\");\n      }\n\n      if (mines >= rows * cols) {\n        this.errors.push(\"Mines cannot outnumber Cells.\");\n      }\n\n      if (mines <= 0) {\n        this.errors.push(\"Mines must be greater than zero.\");\n      }\n\n      if (rows <= 0) {\n        this.errors.push(\"Rows must be greater than zero.\");\n      }\n\n      if (cols <= 0) {\n        this.errors.push(\"Columns must be greater than zero.\");\n      }\n\n      return this.errors.length === 0 ? true : false;\n    },\n\n    allMinesFlagged() {\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          if (this.board[r][c].mine && !this.board[r][c].flag) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n\n    allCellsActive() {\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          if (!this.board[r][c].active) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n\n    revealMines() {\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          this.$set(this.board[r][c], \"reveal\", true);\n        }\n      }\n    }\n  },\n\n  components: {\n    Cell\n  }\n};\n",{"version":3,"sources":["Board.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAoBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"Board.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div id=\"board-component\">\n    <div class=\"row\" v-for=\"(row, i) in board\" :key=\"i\">\n      <div class=\"col\" v-for=\"(col, j) in row\" :key=\"j\">\n        <Cell\n          :mine=\"col.mine\"\n          :flag=\"col.flag\"\n          :active=\"col.active\"\n          :reveal=\"col.reveal\"\n          :row=\"i\"\n          :col=\"j\"\n          :border-mines=\"col.borderMines\"\n          v-on:cell-clicked=\"handleClick\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport Cell from \"@/components/Cell.vue\";\nimport { mapState, mapGetters, mapActions } from \"vuex\";\n\nexport default {\n  name: \"Board\",\n\n  data: () => {\n    return {\n      board: [],\n      rows: 4,\n      cols: 4,\n      mines: 4,\n      safeCells: 0\n    };\n  },\n\n  mounted() {\n    this.generateBoard(this.rows, this.cols, this.mines);\n  },\n\n  computed: {\n    ...mapState({\n      shouldGenerateBoard: state => state.board.shouldGenerateBoard\n    }),\n    ...mapGetters([\"resetRows\", \"resetCols\", \"resetMines\"])\n  },\n\n  watch: {\n    shouldGenerateBoard(shouldGenerate) {\n      if (shouldGenerate) {\n        // console.log(\"watch reset\");\n        // console.log(this.resetRows, this.resetCols, this.resetMines);\n        this.generateBoard(this.resetRows, this.resetCols, this.resetMines);\n      }\n    }\n  },\n\n  methods: {\n    ...mapActions([\"startGame\", \"resetGenerateBoard\"]),\n\n    randomNum: max => {\n      // return a random number between 0 and max inclusively\n      return Math.floor(Math.random() * Math.floor(max));\n    },\n\n    generateBoard(rows = this.rows, cols = this.cols, mines = this.mines) {\n      // console.log(\"Baord.generateBoard\");\n      // console.log(rows);\n      // console.log(cols);\n      // console.log(mines);\n\n      if (!this.validGame(rows, cols, mines)) {\n        // console.log(\"invalid game returning false\");\n        return false;\n      }\n\n      this.rows = rows;\n      this.cols = cols;\n      this.mines = mines;\n\n      // calculate number of cells that are not mines.\n      this.safeCells = rows * cols - mines;\n\n      // Helper function to return a list of cells that do not have a mine place in them.\n      const getAvailableCells = () => {\n        const availableCells = [];\n        for (let i = 0; i < rows; i++) {\n          for (let j = 0; j < cols; j++) {\n            if (!this.board[i][j].mine) {\n              availableCells.push([i, j]);\n            }\n          }\n        }\n        return availableCells;\n      };\n\n      // Initialize board to entirely empty but active cells\n      for (let r = 0; r < rows; r++) {\n        this.$set(this.board, r, []);\n        for (let c = 0; c < cols; c++) {\n          this.$set(this.board[r], c, {\n            mine: false,\n            active: true,\n            borderMines: 0,\n            flag: false,\n            reveal: false\n          });\n        }\n      }\n\n      // Place mines\n      for (let m = 0; m < mines; m++) {\n        const availableCells = getAvailableCells();\n        const randomNum = this.randomNum(availableCells.length);\n        const cell = availableCells[randomNum];\n        const row = cell[0];\n        const col = cell[1];\n        this.$set(this.board[row][col], \"mine\", true);\n      }\n\n      // Determine Border Mines\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          if (!this.board[i][j].mine) {\n            continue;\n          }\n\n          // North\n          if (i - 1 >= 0) {\n            const neighbor = this.board[i - 1][j];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // NorthEast\n          if (i - 1 >= 0 && j + 1 < cols) {\n            const neighbor = this.board[i - 1][j + 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // East\n          if (j + 1 < cols) {\n            const neighbor = this.board[i][j + 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // SouthEast\n          if (i + 1 < rows && j + 1 < cols) {\n            const neighbor = this.board[i + 1][j + 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // South\n          if (i + 1 < rows) {\n            const neighbor = this.board[i + 1][j];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // SouthWest\n          if (i + 1 < rows && j - 1 >= 0) {\n            const neighbor = this.board[i + 1][j - 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // West\n          if (j - 1 >= 0) {\n            const neighbor = this.board[i][j - 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n\n          // NorthWest\n          if (i - 1 >= 0 && j - 1 >= 0) {\n            const neighbor = this.board[i - 1][j - 1];\n            const mines = neighbor.borderMines + 1;\n            this.$set(neighbor, \"borderMines\", mines);\n          }\n        }\n      }\n\n      this.resetGenerateBoard();\n    },\n\n    handleFlagClick(row, col) {\n      // Removing Flag\n      if (this.board[row][col].flag) {\n        this.$set(this.board[row][col], \"flag\", false);\n        this.$set(this.board[row][col], \"active\", true);\n        this.mines++;\n        return;\n      }\n\n      // Replace a number with a flag\n      if (!this.board[row][col].active) {\n        this.$set(this.board[row][col], \"flag\", true);\n        this.mines--;\n        this.safeCells++;\n        return;\n      }\n\n      this.$set(this.board[row][col], \"flag\", true);\n      this.$set(this.board[row][col], \"active\", false);\n      this.mines--;\n\n      // console.log(\"TODO => won Game?  Minesweeper.gameWon()\");\n      // this.gameWon();\n    },\n\n    handleClick(row, col, flag) {\n      // First Click\n      if (this.allCellsActive()) {\n        this.startGame();\n      }\n\n      if (flag) {\n        this.handleFlagClick(row, col);\n        return;\n      }\n\n      // this cell has already been clicked\n      if (!this.board[row][col].active) {\n        return false;\n      }\n\n      // Set Cell to Inactive\n      this.$set(this.board[row][col], \"active\", false);\n      this.safeCells--;\n\n      // Triggered a mine\n      if (this.board[row][col].mine) {\n        this.youLost = true;\n        this.gameActive = false;\n        this.revealMines();\n        this.pauseTimer();\n        return;\n      }\n\n      // console.log(\"TODO => won Game?  Minesweeper.gameWon()\");\n      // this.gameWon();\n    },\n\n    validGame(rows, cols, mines) {\n      this.errors = [];\n\n      if (isNaN(rows)) {\n        this.errors.push(\"Rows is not a number.\");\n      }\n\n      if (isNaN(cols)) {\n        this.errors.push(\"Columns is not a number.\");\n      }\n\n      if (isNaN(mines)) {\n        this.errors.push(\"Mines is not a number.\");\n      }\n\n      if (mines >= rows * cols) {\n        this.errors.push(\"Mines cannot outnumber Cells.\");\n      }\n\n      if (mines <= 0) {\n        this.errors.push(\"Mines must be greater than zero.\");\n      }\n\n      if (rows <= 0) {\n        this.errors.push(\"Rows must be greater than zero.\");\n      }\n\n      if (cols <= 0) {\n        this.errors.push(\"Columns must be greater than zero.\");\n      }\n\n      return this.errors.length === 0 ? true : false;\n    },\n\n    allMinesFlagged() {\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          if (this.board[r][c].mine && !this.board[r][c].flag) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n\n    allCellsActive() {\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          if (!this.board[r][c].active) {\n            return false;\n          }\n        }\n      }\n      return true;\n    },\n\n    revealMines() {\n      for (let r = 0; r < this.rows; r++) {\n        for (let c = 0; c < this.cols; c++) {\n          this.$set(this.board[r][c], \"reveal\", true);\n        }\n      }\n    }\n  },\n\n  components: {\n    Cell\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n@import \"../styles/reset\";\n\n.row {\n  display: flex;\n  justify-content: center;\n}\n</style>\n"]}]}